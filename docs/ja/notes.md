# CosmosチェーンへのGravityのインストール

## 開始されていないチェーンへのGravityのインストール

0.デプロイされたコントラクトアドレスは、バリデーターが生成するgentxに保存されます
   -バリデーターはイーサリアムキーペアを生成し、gentxの一部として送信します
   -バリデーターは、イーサリアムキーペアを使用してgentxバリデーターの状態にも署名します
1. Gentx署名が完了すると、Ethereum署名が収集され、すでにデプロイされているEthereumコントラクトにvalset更新を送信するために使用されます
2.チェーンが開始され、バリデーターはすべてイーサリアムの契約状態を監視し、現在のバリデーターの状態と一致することを確認し、通常どおり更新を続行します

## ライブCosmosチェーンへのGravityのインストール

0.フルノードコードベースに重力コードを受け入れるガバナンス決議があります
   -重力がバリデーターで実行を開始すると、Ethereumキーペアが生成されます。
     -これはconfigから一時的に取得される可能性があります
   --Gravityは、バリデーターのイーサリアムアドレスをブロックごとに公開します。
     -これはおそらく重力キーパーにそれを置くことを意味するでしょうが、おそらくバリデーターセット情報の残りの部分と何らかのより大きな結びつきが必要です
       -個人およびすべてのバリデーターを取得する例については、stakeing/keeper/keeper.goを参照してください
   -このステップでgravityIdが選択されます。
     -これは今のところハードコーディングされている可能性があります
   -重力イーサリアム契約のソースコードハッシュがここに保存されます。
     -これもハードコーディングされている可能性があります
   -後のステップで、すべてのバリデーターがそこにethアドレスを持っていることを確認する必要があります
1.「ブロックxから重力を開始する」というガバナンス決議があります。
   -これは、重力モジュールが探すパラメータ変更の解像度です
1.ブロックxの直後に、重力モジュールはブロックxに設定されたバリデーターを確認し、イーサリアムキーペアを使用して署名します。
1. Gravityは、最後のステップからのイーサリアム署名をコンセンサス状態にします。コンセンサスの一部として、バリデーターはこれらの各署名が有効であることを確認します。
   -最後のブロックから設定されたバリデーターのEthアドレスに対するEth署名が、今後のすべてのブロックで必要になるようになりました。
1.デプロイヤースクリプトはフルノードAPIにヒットし、最新のブロックからvalsetのEthシグネチャを取得し、Ethereumコントラクトをデプロイします。
1.デプロイヤーは、デプロイした重力コントラクトのアドレスをイーサリアムに送信します。
   -多くのデプロイヤーが多くの有効な重力ethコントラクトをデプロイするシナリオを検討します。
   -重力モジュールは、送信された各アドレスのイーサリアムチェーンをチェックし、そのアドレスでの重力コントラクトが正しいソースコードを使用しており、正しいバリデーターが設定されていることを確認します。
1.重力モジュールには、少なくともnブロック後ろにある最初のブロックで最も低いアドレスを持つ正しい重力eth契約アドレスが「公式」契約であるという規則があります。 nブロックが通過した後、これにより、重力を使用して、どのイーサリアム契約に送金するかを知ることができます。

# イーサリアム契約のメッセージを作成する

## バルセットプロセス

-各valのGravityDaemonは、「MsgSetEthAddress」を送信し、ethアドレスとその署名をCosmosアドレスに送信します
-これにより、署名が検証され、EthAddressKeyプレフィックスの下のストアにEthアドレスが追加されます。
-誰かが「MsgValsetRequest」を送信します。
-現在のブロックのvalsetは、ValsetRequestKeyプレフィックスの下でストアに入ります
  -valsetのnonceが現在のブロックの高さとして設定されます
  -valsetは、nonce/blockheightをキーとして使用して保存されます
-重力デーモンがストア内のvalsetを確認すると、ethキーを使用して署名し、MsgValsetConfirmを送信します。これは、検証後にストアに入ります。
  -Gravityデーモンは、ストアに表示されるすべてのvalsetに自動的に署名します。これは、ストアに配置するコンセンサスに参加することで、暗黙的にそれを承認するためです。
  -valset確認は、valset要求のように、ナンスをキーとして使用して保存されます
-重力デーモンの66％が特定のvalsetの署名を送信すると、リレーラーはストアからvalsetと署名にアクセスすることにより、valsetを送信できます。たぶん、これを簡単に行う方法を作るでしょう。

## TXバッチプロセス

-ユーザーは、要求されたEthTX「EthTx」を使用してCosmosTXを送信します
-これはコンセンサスによってみんなの店に入ります
<！-Relayerはストア内のTXからTXバッチを選択します
-リレイヤーは「BatchReqTx」をCosmosに送信し、検証された後、コンセンサスによってBatchReqストアに入り、要求されたバッチに表示されるすべてのEthTxがmempoolから削除されます。 ->
---> GravityモジュールはTXをバッチにソートし、バッチを「BatchStore」に配置し、バッチ内のすべてのEthTXがmempoolから削除されます。

-各バリデーターのGravityDaemonは、BatchStore内のすべてのバッチを確認し、バッチに署名し、すべてのバッチのすべてのeth署名を含む「BatchConfirmTx」を送信します。
-BatchConfirmTxはBatchConfirmStoreに入り、66％になると、リレーがバッチをリレーできるようになります。

-今tバッチはEthコントラクトによって処理されます。
-バリデーターのGravityDaemonsはこれを監視し、「BatchSubmittedTx」を送信します。このTXはBatchSubmittedStoreに入ります。バリデーターの66％以上がBatchSubmittedTxを送信したことを確認すると、cosmosステートマシンはバッチを完全に破棄します。
  -BatchConfirmStoreに古いバッチがある場合、それらは送信できなくなったため、削除されます。古いバッチのEthTxは、mempoolにリリースされます。

## オラクルプロセスをデポジットする

-重力デーモンは常にイーサリアムブロックチェーンを監視します。具体的には、重力イーサリアム契約
-デポジットが観察されると、各バリデーターは50ブロックが経過した後にDepositTXを送信します(フォークを解決するため)
-バリデーターの66％以上がDepositTXでサインオフすると、メッセージハンドラー自体が銀行に呼び出してトークンを生成します

# CosmosSDK/テンダーミントの考慮事項

## 署名

Gravity Ethereumコントラクトのバリデーター状態を更新するには、おそらく最も単純な「オフチェーン作業」を実行する必要があります。イーサリアムキーを使用して現在のバリデーターの状態に署名し、それをメッセージとして送信する
中継者が署名された「ValSetUpdate」メッセージを監視してEthereumに転送できるようにします。

「バリデーターがいくつかの既知の価値に署名する」という概念は、テンダーミントにとって非常に重要であり、もちろん、プルーフ・オブ・ステークシステムでもあります。したがって、重力プロセスのステップとして提示された場合、誰も目をつぶることはありません。ただし、GravityをTendermint拡張機能としてコーディングしているのではなく、CosmosSDKモジュールです。

CosmosSDKモジュールは、バリデーターの秘密鍵または操作する署名コンテキストにアクセスできません。これを回避するために、メインモジュールと相互作用する別のコードベースで署名を実行します。通常、これは「リレイヤー」と呼ばれますが、バリデーターが独自の秘密鍵を使用してアクションを実行する必要があるモジュールを作成しているため、これを「バリデーター外部署名者」またはそれらの線に沿ったものと呼ぶ方がよい場合があります。

外部署名者の必要性により、動作するGravityCosmosSDKモジュールステートマシンを作成するために必要な状態の数が2倍になります。たとえば、ValSetUpdateメッセージ生成プロセスにはトリガーメッセージが必要です。これは、外部の署名者がそれを監視して独自の署名を送信するストアに入ります。状態の更新への署名をトリガーメッセージハンドラー自体の一部として処理できる場合は、この「sigsの待機」状態を排除できます。

これは明らかにショーストッパーではありませんが、メンテナンスが簡単で保守しやすい場合は、ABCIを使用してテンダーミントレベルでこれを行うことを検討する必要があります。

## 重力コンセンサス

TendermintレベルではなくCosmosSDKレベルで署名を実行すると、他の影響があります。主にそれは斬撃と停止条件の性質を変えます。 Tendermintレベルで、ValSetUpdateに署名することがメッセージの処理の一部である場合、そうしないと、そのブロックのそのバリデーターのダウンタイムが発生します。一方、CosmosSDKモジュールでValSetUpdate署名を送信することは単なる別のメッセージであり、追加する可能性のあるスラッシュ条件以外のコンセンサスへの影響はありません。スラッシュ条件は遅いため、これにより次の潜在的な脆弱性が発生します。

バリデーターがValSetUpdatesの生成に失敗し、プロセスがTendermintに実装されている場合、それらは単にダウンタイムを増やしているだけであり、バリデーターとしての機能はありません。ただし、プロセスがCosmosSDKレベルで実装されている場合、それらはバリデーターとして正常に動作し続けます。

ここでの脆弱性についての私の直感は、それらはステークの3分の1を使用して橋を停止するためにのみ使用できるということです。これは、アクティブなステークの3分の1を使用してチェーンを停止するのとほぼ同じなので、問題はないと思います。
イーサリアムイベントフィード

-EthBlockDelayと呼ばれるガバナンスパラメータがあります(例:50ブロック)
-Gravity Daemonsは、Gethから現在のブロック番号を取得し、次に、現在のブロックよりも低いブロックEthBlockDelayからイベントを取得します。
-EthBlockDataメッセージを送信します
-これらのメッセージはEthBlockDataStoreに送られ、ブロック番号とそれらを送信したバリデーターによってインデックスが付けられます。
-バリデーターの少なくとも66％から一致するブロックデータのバージョンがあると、それは正当であると見なされます
-ブロックが66％を超えると(そして以前のすべてのブロックも66％を超えると)、そのブロックでのEthToCosmos転送の結果としてトークンが作成されます。
-(オプションのダウンタイムスラッシュ???)一致するブロックデータを送信していないバリデーターを監視し、ダウンタイムスラッシュをトリガーします

代替の実験的イーサリアム入力

-アカウントがEthから転送されたトークンを取得するためにClaimTokensメッセージを送信する必要があるとしましょう(議論のために)
<！----各バリデーターは(重力デーモンが処理するのではなく)Gethに直接接続します->
-ClaimTokensメッセージが着信すると、ステートマシンの各バリデーターは、自身のethブロックDBをチェックします(これはCosmos KVストアとは別であり、重力モジュールによってのみアクセスされます。重力tyデーモンは、トークンがそのアカウントに転送されているかどうかを確認するために、別のプロセスからのブロックデータでいっぱいにします。
-Ethの状態について異なる意見を持つバリデーターは、異なる結論に到達し、異なるブロックを生成します。 Tendermintによると、同意しないバリデーターにはダウンタイムが発生します。これにより、Tendermintはすべてのコンセンサスを処理できますが、私たちはそれについては考えていません。

イーサリアムからコスモスへの転送

-契約中の機能は、宛先のCosmosアドレスと転送金額を受け取ります
-転送を実行し、EthToCosmosTransferイベントを金額と宛先とともにログに記録します

バリデーターによる代替バッチアセンブリ

-以前に想定したように誰でもバッチを要求できるようにすると、誰かが不採算のバッチを集めてブリッジを停止する攻撃ベクトルが開かれます。
-代わりに、バリデーターにバッチをアセンブルさせないのはなぜですか？
-コスモスステートマシンでは、すべてのトランザクションを調べ、最低料金から最高料金の順に並べ替え、そのリストをバッチに分割します。
-これで、中継者はバッチの送信を試みることができます。
-バッチはEthに送信され、トランザクションは並行してプールに蓄積されます。
-ある時点で、バリデーターは同じ方法でソートされた新しいバッチを作成します。
-中継者は、古い低料金のバッチを無効にする新しいバッチを送信することを選択できます。